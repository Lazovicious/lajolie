<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Admin: Manage Available Time Slots</title>

<!-- FullCalendar CSS -->
<link href="https://cdn.jsdelivr.net/npm/fullcalendar@6.1.8/index.global.min.css" rel="stylesheet" />

<style>
  body {
    font-family: Arial, sans-serif;
    margin: 1rem;
    background: #f9f9f9;
  }
  h1 {
    margin-bottom: 1rem;
  }
  #calendar {
    max-width: 900px;
    margin: 0 auto;
    background: white;
    border-radius: 6px;
    padding: 1rem;
    box-shadow: 0 3px 10px rgb(0 0 0 / 0.1);
  }
  .fc-event.booked {
    background-color: #dc3545 !important; /* red */
    border-color: #b02a37 !important;
  }
  .fc-event.available {
    background-color: #28a745 !important; /* green */
    border-color: #1e7e34 !important;
  }
</style>
</head>
<body>

<h1>Admin: Manage Available Time Slots</h1>
<div id="calendar"></div>

<!-- Supabase -->
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

<!-- FullCalendar -->
<script src="https://cdn.jsdelivr.net/npm/fullcalendar@6.1.8/index.global.min.js"></script>

<script>
(async () => {
  // --- Config: replace with your own Supabase URL and anon key ---
  const SUPABASE_URL = 'https://xkljqcxonrnstuivtihc.supabase.co'; // Your Supabase URL
  const SUPABASE_ANON_KEY = prompt('Enter Supabase anon key for admin:');
  if (!SUPABASE_ANON_KEY) {
    alert('Admin key is required. Reload page to try again.');
    return;
  }

  const supabase = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

  // Table names
  const AVAILABILITY_TABLE = 'availability_slots';
  const BOOKINGS_TABLE = 'jolie_t1';

  // Utility: generate 30-min slots array for a given day
  function generateTimeSlots(dateStr) {
    // Return array of ISO date-times for 30-min increments from 08:00 to 20:00
    const slots = [];
    const baseDate = new Date(dateStr + 'T08:00:00');
    for (let i = 0; i < 24; i++) { // 24 slots of 30 mins from 8am to 8pm
      const slotDate = new Date(baseDate.getTime() + i * 30 * 60000);
      slots.push(slotDate.toISOString());
    }
    return slots;
  }

  // Fetch availability slots from Supabase
  async function fetchAvailability() {
    const { data, error } = await supabase
      .from(AVAILABILITY_TABLE)
      .select('*')
      .order('date', { ascending: true })
      .order('time', { ascending: true });
    if (error) {
      alert('Error fetching availability: ' + error.message);
      return [];
    }
    return data;
  }

  // Fetch booked slots from Supabase
  async function fetchBookings() {
    const { data, error } = await supabase
      .from(BOOKINGS_TABLE)
      .select('date,time')
      .order('date', { ascending: true })
      .order('time', { ascending: true });
    if (error) {
      alert('Error fetching bookings: ' + error.message);
      return [];
    }
    return data;
  }

  // Convert availability and bookings to FullCalendar event format
  function convertToEvents(availability, bookings) {
    const events = [];

    // Bookings are blocked: red and not editable
    bookings.forEach(({ date, time }) => {
      // Combine date and time (time is "HH:mm")
      const start = new Date(`${date}T${time}:00`);
      const end = new Date(start.getTime() + 30 * 60000);
      events.push({
        id: `booked-${date}-${time}`,
        title: 'BOOKED',
        start: start.toISOString(),
        end: end.toISOString(),
        display: 'background',
        classNames: ['booked'],
        editable: false,
      });
    });

    // Availability: green and clickable for removal
    availability.forEach(({ id, date, time, is_available }) => {
      if (is_available) {
        const start = new Date(`${date}T${time}:00`);
        const end = new Date(start.getTime() + 30 * 60000);
        events.push({
          id: `avail-${id}`,
          title: 'Available',
          start: start.toISOString(),
          end: end.toISOString(),
          classNames: ['available'],
          editable: true,
          extendedProps: { dbId: id }
        });
      }
    });

    return events;
  }

  // Insert new availability slot in DB
  async function insertAvailability(dateStr, timeStr) {
    const { data, error } = await supabase
      .from(AVAILABILITY_TABLE)
      .insert([{ date: dateStr, time: timeStr, is_available: true }])
      .select()
      .single();

    if (error) {
      alert('Error adding availability: ' + error.message);
      return null;
    }
    return data;
  }

  // Remove availability slot by id in DB
  async function removeAvailability(id) {
    const { error } = await supabase
      .from(AVAILABILITY_TABLE)
      .delete()
      .eq('id', id);
    if (error) {
      alert('Error removing availability: ' + error.message);
      return false;
    }
    return true;
  }

  // Initialize FullCalendar
  const calendarEl = document.getElementById('calendar');
  const calendar = new FullCalendar.Calendar(calendarEl, {
    initialView: 'timeGridWeek',
    slotDuration: '00:30:00',
    allDaySlot: false,
    nowIndicator: true,
    selectable: true,
    businessHours: { // 8am - 8pm every day
      daysOfWeek: [0,1,2,3,4,5,6],
      startTime: '08:00',
      endTime: '20:00',
    },
    headerToolbar: {
      left: 'prev,next today',
      center: 'title',
      right: 'timeGridDay,timeGridWeek',
    },
    select: async (selectionInfo) => {
      const dateStr = selectionInfo.startStr.slice(0, 10); // yyyy-mm-dd
      const timeStr = selectionInfo.startStr.slice(11,16); // HH:mm

      // Check if this slot is already booked or available
      const overlappingEvents = calendar.getEvents().filter(event => {
        return event.startStr === selectionInfo.startStr;
      });
      if (overlappingEvents.some(e => e.classNames.includes('booked'))) {
        alert('This time slot is already booked and cannot be made available.');
        calendar.unselect();
        return;
      }
      if (overlappingEvents.some(e => e.classNames.includes('available'))) {
        alert('This time slot is already available.');
        calendar.unselect();
        return;
      }

      // Confirm add availability
      if (confirm(`Add availability on ${dateStr} at ${timeStr}?`)) {
        const newSlot = await insertAvailability(dateStr, timeStr);
        if (newSlot) {
          calendar.addEvent({
            id: `avail-${newSlot.id}`,
            title: 'Available',
            start: new Date(`${dateStr}T${timeStr}:00`).toISOString(),
            end: new Date(new Date(`${dateStr}T${timeStr}:00`).getTime() + 30*60000).toISOString(),
            classNames: ['available'],
            editable: true,
            extendedProps: { dbId: newSlot.id }
          });
          alert('Availability added!');
        }
      }
      calendar.unselect();
    },
    eventClick: async (info) => {
      if (info.event.classNames.includes('booked')) {
        alert('This slot is booked and cannot be modified.');
        return;
      }
      if (info.event.classNames.includes('available')) {
        if (confirm(`Remove availability for ${info.event.startStr.slice(0,16).replace('T',' ')}?`)) {
          const id = info.event.extendedProps.dbId;
          const success = await removeAvailability(id);
          if (success) {
            info.event.remove();
            alert('Availability removed.');
          }
        }
      }
    },
  });

  // Load and render events
  async function loadAndRender() {
    const availability = await fetchAvailability();
    const bookings = await fetchBookings();
    const events = convertToEvents(availability, bookings);
    calendar.removeAllEvents();
    calendar.addEventSource(events);
  }

  // Start calendar
  calendar.render();
  await loadAndRender();

  // Optionally refresh availability every 5 minutes
  setInterval(loadAndRender, 300000);

})();
</script>

</body>
</html>
